# GLYPH Benchmark Results

**Date:** 2025-12-20
**Corpus:** 1.0 (55 test cases)
**GLYPH Version:** 1.0.0
**Tokenizer:** tiktoken (cl100k_base, o200k_base)

## Summary

Comparison of GLYPH-Loose vs ZON vs TOON vs JSON-minified across 55 test cases.

| Codec | Bytes | cl100k tokens | o200k tokens |
|-------|------:|--------------:|-------------:|
| **zon** | 3,878 | 1,915 | 1,909 |
| **glyph_loose** | 4,224 | 1,895 | 1,873 |
| json_min | 5,109 | 2,117 | 2,113 |
| toon | 5,440 | 2,466 | 2,445 |

## Rankings

### By Bytes (smaller is better)
1. **ZON** - 3,878 bytes (24.1% savings vs JSON)
2. **GLYPH-Loose** - 4,224 bytes (17.3% savings vs JSON)
3. JSON-min - 5,109 bytes (baseline)
4. TOON - 5,440 bytes (+6.5% overhead)

### By Tokens (smaller is better for LLM cost)

**cl100k_base (GPT-4, GPT-3.5-turbo):**
1. **GLYPH-Loose** - 1,895 tokens (10.5% savings)
2. **ZON** - 1,915 tokens (9.5% savings)
3. JSON-min - 2,117 tokens (baseline)
4. TOON - 2,466 tokens (+16.5% overhead)

**o200k_base (GPT-4o):**
1. **GLYPH-Loose** - 1,873 tokens (11.4% savings)
2. **ZON** - 1,909 tokens (9.7% savings)
3. JSON-min - 2,113 tokens (baseline)
4. TOON - 2,445 tokens (+15.7% overhead)

## Key Insights

1. **GLYPH wins on tokens** - Despite ZON being smaller in bytes, GLYPH produces fewer tokens for both tokenizers. This is the metric that matters for LLM API costs.

2. **ZON wins on bytes** - ZON's tabular compression is highly effective for raw byte count, achieving 24.1% reduction.

3. **TOON is larger than JSON** - On this corpus, TOON's YAML-like format actually increases size by 6.5% bytes and 16% tokens.

4. **Token efficiency matters** - GLYPH's syntax (bare keys, `=` instead of `:`, no quotes) aligns better with how tokenizers split text.

## Savings vs JSON-min

| Codec | Bytes | cl100k | o200k |
|-------|------:|-------:|------:|
| glyph_loose | +885 (+17.3%) | +222 (+10.5%) | +240 (+11.4%) |
| zon | +1,231 (+24.1%) | +202 (+9.5%) | +204 (+9.7%) |
| toon | -331 (-6.5%) | -349 (-16.5%) | -332 (-15.7%) |

## Methodology

- **JSON:** Minified (no whitespace), using Python's `json.dumps` with `separators=(',', ':')`
- **GLYPH:** Canonical GLYPH-Loose format via `glyph.CanonicalizeLoose`
- **ZON:** `zon-format@1.3.0` npm package
- **TOON:** `@toon-format/toon@2.1.0` npm package
- **Tokens:** Counted using `tiktoken` library with cl100k_base and o200k_base encodings

## Why GLYPH Wins on Tokens

GLYPH's syntax is designed for tokenizer efficiency:

```
JSON:  {"id":"evt_123","type":"user.created","data":{"user":{"id":"u_1"}}}
GLYPH: {data={user={id=u_1}} id=evt_123 type=user.created}
ZON:   data{user{id:u_1}}\nid:evt_123\ntype:user.created
```

Key differences:
- **Bare keys** - No quotes around keys saves tokens
- **`=` vs `:`** - Equals sign often tokenizes with adjacent text
- **Alphabetical ordering** - Predictable structure aids compression
- **No trailing punctuation** - Fewer separator tokens

## Test Corpus

55 JSON test cases covering:
- Empty objects/arrays
- Nested structures (10-20 levels deep)
- Unicode and escape sequences
- Large integers and floats
- API-like payloads
- Many keys (50+)
- Edge cases (duplicate keys, numeric keys, etc.)

## Reproduce

```bash
cd sjson/glyph
python3 bench/harness.py --config bench/config.yaml --root .
```

Requires:
- Python 3.8+
- `pyyaml` and `tiktoken` packages
- Go (for GLYPH CLI)
- Node.js (for ZON/TOON)
